<#@ include file="Imports.ttinclude"#>
<#@ include file="Utils.ttinclude"#>
<#@ include file="Header.ttinclude"#>
<#@ include file="VsHelperInit.ttinclude"#>
<#
//System.Diagnostics.Debugger.Launch();
//System.Diagnostics.Debugger.Break();	

var debug = true;


var globalWatch = Stopwatch.StartNew();
var stepWatch = debug ? Stopwatch.StartNew() : null;

GlobalContainer.VSHelper = VSHelper;
GlobalContainer.ProjectItems = VSHelper.GetAllProjectItems();
GlobalContainer.ProjectTypes = VSHelper.GetAllTypes(GlobalContainer.ProjectItems);
GlobalContainer.Settings = XmlSettings.Load(VSHelper.Host.TemplateFile + ".settings.xml");
GlobalContainer.KnownNamespaces = new HashSet<string>
    {
        "System",
        "System.Collections.Generic",
        "System.ComponentModel",
        "System.CodeDom.Compiler",
		"System.Linq",
        "System.Linq.Expressions",
        "System.Reflection",
        "FluentNHibernate.Automapping",
    };
if (GlobalContainer.Settings.GenerateMetadata.Relations)
    GlobalContainer.KnownNamespaces.Add("T4FluentNH.Metadata");

//reset static props
GlobalContainer.Reset();

if (debug)
{
    stepWatch.Stop();
	VSHelper.Warning("Setting Global container: " + stepWatch.ElapsedMilliseconds);    
}


/*TODOS*/
//TODO: Strict - do note that non public getter or setter are not serialized/deserialized by default with Json.net

#region Overrides
if (debug) 
	stepWatch = Stopwatch.StartNew(); 

//Get and save all overrides
VSHelper.ProcessFiles(GlobalContainer.ProjectItems, (file, name) => VSHelper.ProcessTypes(file, (type, pItem) => 
    {
        if (VSHelper.GetAttribute(type.Attributes, "System.CodeDom.Compiler.GeneratedCodeAttribute") != null)
        {
            if (!GlobalContainer.EntityProjectItems.ContainsKey(type.FullName))
                GlobalContainer.EntityProjectItems.Add(type.FullName, new EntityProjectItem(type.FullName));
            GlobalContainer.EntityProjectItems[type.FullName].SetGeneratedFile(pItem);
            return;
        }
        if(type.IsDerivedFrom[GlobalContainer.Settings.BaseEntityType] && !GlobalContainer.Settings.IgnoreTypes.Contains(type.FullName))
        {
			if (!GlobalContainer.EntityProjectItems.ContainsKey(type.FullName))
                GlobalContainer.EntityProjectItems.Add(type.FullName, new EntityProjectItem(type.FullName));
			GlobalContainer.EntityProjectItems[type.FullName].AddEntityFile(pItem);

			GlobalContainer.DomainProjectItems.Add(pItem);

            return;
        }
        var mapOverride =
            type.ImplementedInterfaces.OfType<CodeElement>()
                .FirstOrDefault(o => o.FullName.Contains("IAutoMappingOverride"));

		if(mapOverride == null) return;
		var overrideType = VSHelper.GetGenericAgruments(mapOverride.FullName)[0];
		if(overrideType == null) return;
		if(!GlobalContainer.Overrides.ContainsKey(overrideType))
			GlobalContainer.Overrides.Add(overrideType, new Dictionary<string, ModelRelation>());

		//VSHelper.Warning("Overrides found for type " + overrideType);

		if (!GlobalContainer.EntityProjectItems.ContainsKey(overrideType))
			GlobalContainer.EntityProjectItems.Add(overrideType, new EntityProjectItem(type.FullName));

		GlobalContainer.EntityProjectItems[overrideType].AddOverrideFile(pItem);

        EntityType entityType = null;

		//Get properties for overriden type
		var properties = new Dictionary<string, CodeProperty>();
		foreach(var partialType in GlobalContainer.ProjectTypes[overrideType])
		{
		    if (entityType == null)
		        entityType = GlobalContainer.Settings.GetEntityType(VSHelper, partialType, false);

		    foreach (var p in VSHelper.GetProperties(partialType))
		    {
		        if(properties.ContainsKey(p.Name))
					throw new Exception(string.Format("Duplicate property {0} inside type {1}", p.Name, partialType.FullName));
				properties.Add(p.Name, p);
		    }
				
        }

        if(entityType == null)
            throw new Exception("EntityType for type " + overrideType + " does not exists");

		//get override method
		var method = VSHelper.GetMethod(type, "Override");
		if(method == null) return;
		var functionText = VSHelper.GetCodeFunctionText(method);
		
        //Components
        var compRegex = new Regex(@"\.Component\([\w\s]+=>[\s\w]+\.([\w\d]+)");
        var compMatches = compRegex.Matches(functionText);
        foreach (var match in compMatches.OfType<Match>().Where(o => o.Success))
        {
            var propName = match.Groups[1].Value;
            if(!properties.ContainsKey(propName)) continue;
            var prop = properties[propName];
            if(prop == null) throw new Exception("prop null");
            if(!GlobalContainer.Components.ContainsKey(overrideType))
                GlobalContainer.Components.Add(overrideType, new Dictionary<string, CodeProperty>());
            GlobalContainer.Components[overrideType].Add(propName, prop);
        }

        //oneToMany relation
		var oneToManyRegex = new Regex(@"\.HasMany\([\w\s]+=>[\s\w]+\.([\w\d]+)\)([^;]*)");
		var oneToManyMatches = oneToManyRegex.Matches(functionText);
		foreach(var match in oneToManyMatches.OfType<Match>().Where(o => o.Success))
        {
			var propName = match.Groups[1].Value;
			var extraCalls = match.Groups[2].Value;
            if(!properties.ContainsKey(propName)) continue;
            var prop = properties[propName];
            if(prop == null) throw new Exception("prop null");
			var relatedPropType = VSHelper.GetGenericAgruments(prop.Type).First();
			if(relatedPropType == null) throw new Exception("relatedPropType null");

            var relatedPropName = "";
            var keyColumn = "";

            //KeyColumn - support KeyColumn(o => o.Category) or KeyColumn("CategoryId")
            var keyColumnRegex = new Regex(@"\.KeyColumn\([\w\s]+=>[\s\w]+\.([\w\d]+)\)|\.KeyColumn\(""([\w\d]+)""\)");
		    var keyColumnMatches = keyColumnRegex.Matches(extraCalls);
            foreach (var keyColumnMatch in keyColumnMatches.OfType<Match>().Where(o => o.Success))
            {
                keyColumn = !string.IsNullOrEmpty(keyColumnMatch.Groups[1].Value)
                    ? entityType.KeyColumnPrefix + keyColumnMatch.Groups[1].Value + entityType.KeyColumnPostfix
                    : keyColumnMatch.Groups[2].Value;
                relatedPropName = VSHelper.Trim(keyColumn, entityType.KeyColumnPrefix, entityType.KeyColumnPostfix);
            }

            //PropertyRef - support PropertyRef(o => o.Category) or PropertyRef("CategoryId")
            var propRefRegex = new Regex(@"\.PropertyRef\([\w\s]+=>[\s\w]+\.([\w\d]+)\)|\.PropertyRef\(""([\w\d]+)""\)");
		    var propRefMatches = propRefRegex.Matches(extraCalls);
            foreach (var propRefMatch in propRefMatches.OfType<Match>().Where(o => o.Success))
            {
                relatedPropName = !string.IsNullOrEmpty(propRefMatch.Groups[1].Value)
                    ? propRefMatch.Groups[1].Value
                    : propRefMatch.Groups[2].Value;
            }

            if (string.IsNullOrEmpty(relatedPropName)) continue;

            //CollectionType - support AsBag(), AsList(), AsSet
            var collTypeRegex = new Regex(@"\.(AsList|AsSet|AsBag)");
            var collTypeMatches = collTypeRegex.Matches(extraCalls);
            var colType = CollectionMapType.Unknown;
            foreach (var collTypeMatch in collTypeMatches.OfType<Match>().Where(o => o.Success))
            {
                var cType = collTypeMatch.Groups[1].Value;
                switch(cType)
                {
                    case "AsSet":
                        colType = CollectionMapType.Set;
                        break;
                    case "AsList":
                        colType = CollectionMapType.List;
                        break;
                    case "AsBag":
                        colType = CollectionMapType.Bag;
                        break;
                }
            }

            var relatedProp = VSHelper.GetProperties(GlobalContainer.ProjectTypes[relatedPropType], true).FirstOrDefault(o => o.Name == relatedPropName);
            var assocType = relatedProp == null ? AssociationType.Unidirectional : AssociationType.Bidirectional;
            
            //Add oneToMany
			GlobalContainer.Overrides[overrideType].Add(propName,
				new OneToManyModelRelation
						{
							RelatedModelTypeFullName =relatedPropType,
							CollectionType = VSHelper.GetPropertyType(prop),
                            CollectionMapType = colType,
							Property = prop, //many
                            KeyColumn = keyColumn,
							PathInRelatedModel = relatedProp == null ? null : relatedPropName, //one
                            AssociationType = assocType
						});

            //Add manyToOne
            var manyToOneRelation = new ManyToOneModelRelation
            {
                RelatedModelTypeFullName = overrideType,
                Property = relatedProp,
                KeyColumn = keyColumn,
                PathInRelatedModel = propName,
                AssociationType = assocType
            };

            if (relatedProp == null) //Unidirectional association
            {
                GlobalContainer.AddGlobalModelRelation(relatedPropType, manyToOneRelation);
            }
            else
            {
                if(!GlobalContainer.Overrides.ContainsKey(relatedPropType))
				    GlobalContainer.Overrides.Add(relatedPropType, new Dictionary<string, ModelRelation>());
                GlobalContainer.Overrides[relatedPropType].Add(relatedPropName, manyToOneRelation);
            }

        }

		//oneToOne relation
		var oneToOneRegex = new Regex(@"\.HasOne\([\w\s]+=>[\s\w]+\.([\w\d]+)\)([^;]*)");
		var oneToOneMatches = oneToOneRegex.Matches(functionText);
		foreach(var match in oneToOneMatches.OfType<Match>().Where(o => o.Success))
        {
			var propName = match.Groups[1].Value;
			var extraCalls = match.Groups[2].Value;
			var prop = properties[propName];
			if(prop == null) throw new Exception("prop null");
			var relatedPropType = prop.Type.CodeType.FullName;

            //PropertyRef - support PropertyRef(o => o.Category) or PropertyRef("CategoryId")
            var propRefRegex = new Regex(@"\.PropertyRef\([\w\s]+=>[\s\w]+\.([\w\d]+)\)|\.PropertyRef\(""([\w\d]+)""\)");
		    var propRefMatches = propRefRegex.Matches(extraCalls);
            var relatedPropName = "";
            foreach (var propRefMatch in propRefMatches.OfType<Match>().Where(o => o.Success))
            {
                relatedPropName = !string.IsNullOrEmpty(propRefMatch.Groups[1].Value)
                    ? propRefMatch.Groups[1].Value
                    : propRefMatch.Groups[2].Value;
            }
            if (string.IsNullOrEmpty(relatedPropName)) continue;
            var relatedProp = VSHelper.GetProperties(GlobalContainer.ProjectTypes[relatedPropType]).First(o => o.Name == relatedPropName);

			//Add oneToOne
			GlobalContainer.Overrides[overrideType].Add(propName,
				new OneToOneModelRelation
						{
							RelatedModelTypeFullName = relatedPropType,
							Property = prop, 
							PathInRelatedModel = relatedPropName ,
                            AssociationType = AssociationType.Bidirectional
						});
			//Add one to one
			if(!GlobalContainer.Overrides.ContainsKey(relatedPropType))
				GlobalContainer.Overrides.Add(relatedPropType, new Dictionary<string, ModelRelation>());

			if(!GlobalContainer.Overrides[relatedPropType].ContainsKey(relatedPropName)) //if is not self related
            {
				GlobalContainer.Overrides[relatedPropType].Add(relatedPropName,
				new OneToOneModelRelation
						{
							RelatedModelTypeFullName = overrideType,
							Property = relatedProp, 
							PathInRelatedModel = propName,
                            AssociationType = AssociationType.Bidirectional
						});
            }
        }

		//manyToMany relation
		var manyToManyRegex = new Regex(@"\.HasManyToMany\([\w\s]+=>[\s\w]+\.([\w\d]+)\)");
		var manyToManyMatches = manyToManyRegex.Matches(functionText);
		foreach(Match match in manyToManyMatches)
        {
			if (!match.Success) continue;
			var propName = match.Groups[1].Value;
			var prop = properties[propName];
			if(prop == null) throw new Exception("prop null");
			var relatedPropType = VSHelper.GetGenericAgruments(prop.Type).First();

			foreach(var relPartialType in GlobalContainer.ProjectTypes[relatedPropType])
            {
				foreach(var relTypeProp in VSHelper.GetProperties(relPartialType))
				{
					//VSHelper.Warning(type.FullName + " - " +overrideType + " - " + relTypeProp.Name +" - "+ VSHelper.GetGenericAgruments(relTypeProp.Type).FirstOrDefault());
					if(
						VSHelper.IsNHibernateProperty(relTypeProp) &&
						VSHelper.IsGeneric(relTypeProp.Type) &&
						VSHelper.GetGenericAgruments(relTypeProp.Type).FirstOrDefault() == overrideType &&
						!GlobalContainer.Overrides[overrideType].ContainsKey(propName))
                    {
						//add manyToMany
						GlobalContainer.Overrides[overrideType].Add(propName,
							new ManyToManyModelRelation
									{
										RelatedModelTypeFullName = relatedPropType,
										CollectionType = VSHelper.GetPropertyType(prop),
										Property = prop, 
										PathInRelatedModel = relTypeProp.Name,
                                        AssociationType = AssociationType.Bidirectional
									});
                    }	
				}
            }

			
        }
	}));

#endregion

if (debug)
{
    stepWatch.Stop();
	VSHelper.Warning("Process overrides: " + stepWatch.ElapsedMilliseconds);
	stepWatch = Stopwatch.StartNew(); 
}

var manager = Manager.Create(Host, GenerationEnvironment);

VSHelper.ProcessFiles(GlobalContainer.DomainProjectItems, (file, name) => 
	VSHelper.ProcessTypes(file, (type, pItem) => 
		{
			if(VSHelper.GetAttribute(type.Attributes, "System.CodeDom.Compiler.GeneratedCodeAttribute") != null) return;
			//VSHelper.GetAllCodeElementsOfType(type.)
			if(!type.IsDerivedFrom[GlobalContainer.Settings.BaseEntityType] || GlobalContainer.Settings.IgnoreTypes.Contains(type.FullName)) return;
			//VSHelper.Warning(pItem.get_FileNames(0) + " gener created: " + (GlobalContainer.GeneratedFiles.ContainsKey(type.FullName) ?  File.GetCreationTime(GlobalContainer.GeneratedFiles[type.FullName]).ToString() : "WTF") + " gener modif: " + (GlobalContainer.GeneratedFiles.ContainsKey(type.FullName) ?  File.GetLastWriteTime(GlobalContainer.GeneratedFiles[type.FullName]).ToString() : "WTF") + " real: " + File.GetLastWriteTime(pItem.get_FileNames(0)));
			
		    var entityPItem = GlobalContainer.EntityProjectItems[type.FullName];
			var domainModelModified = entityPItem.IsDirty();

		    if (!domainModelModified)
		    {
		        manager.KeepGeneratedFile(entityPItem.GeneratedFileAbsoultePath);
		    }
		    else
		    {
		        VSHelper.Warning(string.Format("Type '{0}' was modified", type.FullName));
		    }

		    var domainClass = new DomainModelWrapper
		    {
		        CodeClass = type,
		        ProjectItem = pItem,
				WasModified = domainModelModified,
				SettingsXml = entityPItem.Serialize()
		    };

			if(!GlobalContainer.DomainClasses.ContainsKey(type.FullName))
				GlobalContainer.DomainClasses.Add(type.FullName, domainClass);
			else
				GlobalContainer.DomainClasses[type.FullName].Merge(domainClass);
			//Warning(string.Format("Processing type: '{0}' with parameter WasModified = {1}", type.FullName, domainModelModified));
		}));

if (debug)
{
    stepWatch.Stop();
    VSHelper.Warning("Filling domian classes: " + stepWatch.ElapsedMilliseconds);
    stepWatch = Stopwatch.StartNew();
}

//Initialize All DomainClasses
foreach (var domainClass in GlobalContainer.DomainClasses.Where(o => o.Value.WasModified))
{
	
	var typeWatch = debug ? Stopwatch.StartNew() : null; 
    domainClass.Value.Initialize();
    if (debug)
    {
        typeWatch.Stop();
		VSHelper.Warning("Initializing domian class: " + domainClass.Value.FileName + ", Time: " + typeWatch.ElapsedMilliseconds);
    }
	
}
if (debug)
{
    stepWatch.Stop();
    VSHelper.Warning("Initializing domian classes: " + stepWatch.ElapsedMilliseconds);
}

manager.StartHeader(); 
#>
//----------------------
// <auto-generated>
//	Generated by T4FluentNH.
// </auto-generated>
//----------------------
// ReSharper disable All
<#
foreach (var ns in GlobalContainer.KnownNamespaces)
{
#>
using <#=ns#>;
<#
}
manager.EndBlock(); 

foreach(var type in GlobalContainer.DomainClasses.Values.Where(o => o.WasModified))
{
	manager.StartNewFile(string.Format("{0}.generated.cs", type.FileName)); 
#>
//<#=type.SettingsXml#>
namespace <#=type.Namespace.FullName#>
{
	[GeneratedCode("T4Template", "1.0")]
	public partial class <#=type.FullClassName#>
	{

<#
	if (GlobalContainer.Settings.GenerateMetadata.Relations)
	{
#>
		#region RelationsMetadata
		#pragma warning disable

		public new static readonly Dictionary<string, RelationMetadata> RelationsMetadata =
            new Dictionary<string, RelationMetadata>
            {
<#
		foreach (var relation in type.RelatedModels.Where(o => o.Property != null))
		{
		    switch (relation.Type)
		    {
				case ModelRelationType.OneToMany:
				case ModelRelationType.ManyToMany:
		            var collectionRelation = (CollectionModelRelation)relation;
		            var classPrefix = ModelRelationType.OneToMany == relation.Type
		                ? "OneToMany"
		                : "ManyToMany";
#>
                {"<#=relation.PropertyName #>", new <#=classPrefix #>RelationMetadata
                {
					RelatedModelType = typeof(<#=relation.RelatedModelTypeName#>),
<#
		            if (!string.IsNullOrEmpty(relation.PathInRelatedModel))
		            {
#>
					RelatedModelProperty = typeof(<#=relation.RelatedModelTypeName#>).GetProperty("<#=relation.PathInRelatedModel#>"),
<#
		            }
#>
					RelatedModelIdProperty = typeof(<#=relation.RelatedModelTypeName#>).GetProperty("<#=relation.RelatedModelIdPropertyName#>"),
					AssociationType = AssociationType.<#=relation.AssociationType#>,
					Field = typeof(<#=type.FullClassName#>).GetField("<#=relation.FieldName#>", BindingFlags.Instance | BindingFlags.NonPublic),
					ParameterName = "<#=relation.ParameterName#>",
					Property = typeof(<#=type.FullClassName#>).GetProperty("<#=relation.PropertyName#>"),
<#
		            if (relation.AssociationType == AssociationType.Bidirectional)
		            {
#>
                    AddMethod = typeof(<#=type.FullClassName#>).GetMethods().FirstOrDefault(o => o.Name == "<#=collectionRelation.AddMethodName#>" && o.GetParameters().Length == 1 && o.GetParameters()[0].ParameterType == typeof(<#=collectionRelation.RelatedModelTypeName#>)),
					RemoveMethod = typeof(<#=type.FullClassName#>).GetMethods().FirstOrDefault(o => o.Name == "<#=collectionRelation.RemoveMethodName#>" && o.GetParameters().Length == 1 && o.GetParameters()[0].ParameterType == typeof(<#=collectionRelation.RelatedModelTypeName#>)),
<#
		            }
#>
					CollectionMapType = CollectionMapType.<#=collectionRelation.CollectionMapType.ToString()#>,
					
                }},
		
<#
					break;
				case ModelRelationType.OneToOne:
				case ModelRelationType.ManyToOne:
		            var oneRelation = (OneModelRelation)relation;
					var manyToOneRelation = relation as ManyToOneModelRelation;
		            var oneClassPrefix = ModelRelationType.OneToOne == relation.Type
		                ? "OneToOne"
		                : "ManyToOne";
#>
                {"<#=relation.PropertyName #>", new <#=oneClassPrefix #>RelationMetadata
                {
					RelatedModelType = typeof(<#=relation.RelatedModelTypeName#>),
<#
		            if (!string.IsNullOrEmpty(relation.PathInRelatedModel))
		            {
#>
					RelatedModelProperty = typeof(<#=relation.RelatedModelTypeName#>).GetProperty("<#=relation.PathInRelatedModel#>"),
<#
		            }
#>
					RelatedModelIdProperty = typeof(<#=relation.RelatedModelTypeName#>).GetProperty("<#=relation.RelatedModelIdPropertyName#>"),
					AssociationType = AssociationType.<#=relation.AssociationType#>,
					Field = typeof(<#=type.FullClassName#>).GetField("<#=relation.FieldName#>", BindingFlags.Instance | BindingFlags.NonPublic),
					ParameterName = "<#=relation.ParameterName#>",
					Property = typeof(<#=type.FullClassName#>).GetProperty("<#=relation.PropertyName#>"),
<#
		            if (relation.AssociationType == AssociationType.Bidirectional)
		            {
#>
					SetMethod = typeof(<#=type.FullClassName #>).GetMethods().FirstOrDefault(o => o.Name == "<#=oneRelation.SetMethodName #>" && o.GetParameters().Length == 1 && o.GetParameters()[0].ParameterType == typeof(<#=oneRelation.RelatedModelTypeName #>)),
					UnsetMethod = typeof(<#=type.FullClassName #>).GetMethods().FirstOrDefault(o => o.Name == "<#=oneRelation.UnsetMethodName #>" && o.GetParameters().Length == 0),
<#
		            }
		            if (!string.IsNullOrEmpty(oneRelation.SyntheticPropertyName))
		            {
#>
					SyntheticProperty = typeof(<#=type.FullClassName#>).GetProperty("<#=oneRelation.SyntheticPropertyName#>"),
					SyntheticField = typeof(<#=type.FullClassName#>).GetField("<#=oneRelation.SyntheticFieldName#>", BindingFlags.Instance | BindingFlags.NonPublic),
					SyntheticPropertyMaxLength = <#=(string.IsNullOrEmpty(oneRelation.SyntheticPropertyMaxLength) ? "null" : oneRelation.SyntheticPropertyMaxLength)#>,
					IsSyntheticPropertyTypeRequired = <#=(oneRelation.IsSyntheticPropertyTypeRequired ? "true" : "false")#>,
<#
		            }
		            if (manyToOneRelation != null && !string.IsNullOrEmpty(manyToOneRelation.RelatedTypeRemoveMethodName))
					{
#>
					RelatedModelRemoveMethod = typeof(<#=relation.RelatedModelTypeName#>).GetMethods().FirstOrDefault(o => o.Name == "<#=manyToOneRelation.RelatedTypeRemoveMethodName#>" && o.GetParameters().Length == 1 && o.GetParameters()[0].ParameterType == typeof(<#=type.FullClassName#>)),
<#
					}
#>					
                }},
		
<#
		            break;
		    }
		}
#>
            };
		#pragma warning restore
		#endregion

<#
	}
    if (GlobalContainer.Components.ContainsKey(type.FullName))
    {
#>
        #region Components fileds
<#
        foreach (var comp in GlobalContainer.Components[type.FullName])
        {
#>
        private <#=comp.Value.Type.AsFullName#> <#=VSHelper.GetFieldName(comp.Key)#>;
<#
        }
#>
        #endregion
<#
    }
#>
<#
	foreach(var relation in type.RelatedModels)
	{
#>
		#region <#=relation.PropertyName#>

<#
		switch(relation.Type)
        {
			case ModelRelationType.OneToMany:
                var oneToManyRelation = (OneToManyModelRelation) relation;
#>
		private <#=oneToManyRelation.FieldCollectionType#> <#=oneToManyRelation.FieldName#>;
<#
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
                    if (!oneToManyRelation.ExistsAddMethod)
                    {
#>

        public virtual void <#=oneToManyRelation.AddMethodName #>(<#=oneToManyRelation.RelatedModelTypeName #> <#=oneToManyRelation.ParameterName #>)
        {
            this.AddOneToMany(o => o.<#=relation.PropertyName #>, <#=oneToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>, o=> o.<#=oneToManyRelation.RemoveMethodName #>);
        }
<#
                    }
					if (!oneToManyRelation.ExistsRemoveMethod)
					{
#>

        public virtual void <#=oneToManyRelation.RemoveMethodName #>(<#=oneToManyRelation.RelatedModelTypeName #> <#=oneToManyRelation.ParameterName #>)
        {
			this.RemoveOneToMany(o => o.<#=relation.PropertyName #>, <#=oneToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
					}
                }
                break;
			case ModelRelationType.ManyToMany:
				var manyToManyRelation = (ManyToManyModelRelation) relation;
#>
		private <#=manyToManyRelation.FieldCollectionType#> <#=manyToManyRelation.FieldName#>;
<#
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
                    if (!manyToManyRelation.ExistsAddMethod)
                    {
#>
        public virtual void <#=manyToManyRelation.AddMethodName#>(<#=manyToManyRelation.RelatedModelTypeName#> <#=manyToManyRelation.ParameterName#>)
        {
            this.AddManyToMany(o => o.<#=relation.PropertyName #>, <#=manyToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
					if (!manyToManyRelation.ExistsRemoveMethod)
					{
#>

        public virtual void <#=manyToManyRelation.RemoveMethodName #>(<#=manyToManyRelation.RelatedModelTypeName #> <#=manyToManyRelation.ParameterName #>)
        {
            this.RemoveManyToMany(o => o.<#=relation.PropertyName #>, <#=manyToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
					}
                }
                break;
			case ModelRelationType.ManyToOne:
				var manyToOneRelation = (ManyToOneModelRelation) relation;
                if (manyToOneRelation.GenerateSyntheticProperty)
                {
#>
        private <#=relation.RelatedModelTypeName#> <#=relation.FieldName#>;

<#  
                    foreach (var attr in GlobalContainer.Settings.SyntheticProperties.CustomAttributes)
                    {
#>
        [<#=attr#>]
<#                       
                    }
                    if (manyToOneRelation.IsSyntheticPropertyTypeRequired && !string.IsNullOrEmpty(GlobalContainer.Settings.NotNullAttribute) && GlobalContainer.Settings.SyntheticProperties.AddNotNullAttribute)
                    {
#>
        [<#=GlobalContainer.Settings.NotNullAttribute#>]
<#
                    }
                    if (!string.IsNullOrEmpty(manyToOneRelation.SyntheticPropertyMaxLength) && !string.IsNullOrEmpty(GlobalContainer.Settings.LengthAttribute) && GlobalContainer.Settings.SyntheticProperties.AddLengthAttribute)
                    {
#>
        [<#=GlobalContainer.Settings.LengthAttribute#>(<#=manyToOneRelation.SyntheticPropertyMaxLength#>)]
<#
                    }
					if(relation.Property == null)
					{
#>
        public virtual <#=manyToOneRelation.SyntheticPropertyTypeName#> <#=manyToOneRelation.SyntheticPropertyName#> { get; <#=GlobalContainer.Settings.Strict ? "protected " : ""#>set; }
<#
					}
					else
					{
#>
		public virtual <#=manyToOneRelation.SyntheticPropertyTypeName#> <#=manyToOneRelation.SyntheticPropertyName#> 
		{ 
			get { return <#=manyToOneRelation.SyntheticFieldName#> != default(<#=manyToOneRelation.SyntheticPropertyTypeName#>) || <#=manyToOneRelation.PropertyName#> == null ? <#=manyToOneRelation.SyntheticFieldName#> : <#=manyToOneRelation.PropertyName#>.<#=manyToOneRelation.RelatedModelIdPropertyName#>; } 
			<#=GlobalContainer.Settings.Strict ? "protected " : ""#>set { <#=manyToOneRelation.SyntheticFieldName#> = value; }
		}

		private <#=manyToOneRelation.SyntheticPropertyTypeName#> <#=manyToOneRelation.SyntheticFieldName#>;
<#
					}    
                }
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
					if(!manyToOneRelation.ExistsSetMethod)
					{
#>

        public virtual void <#=manyToOneRelation.SetMethodName #>(<#=manyToOneRelation.RelatedModelTypeName #> <#=manyToOneRelation.ParameterName #>)
        {
			this.SetManyToOne(o => o.<#=manyToOneRelation.PropertyName #>, <#=manyToOneRelation.ParameterName #>, o => o.<#=manyToOneRelation.RelatedTypeRemoveMethodName#>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
					if (!manyToOneRelation.ExistsUnsetMethod)
					{
#>

        public virtual void <#=manyToOneRelation.UnsetMethodName #>()
        {
			this.UnsetManyToOne(o => o.<#=manyToOneRelation.PropertyName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
					}
                }
                break;
			case ModelRelationType.OneToOne:
				var oneToOneRelation = (OneToOneModelRelation) relation;
                if (oneToOneRelation.GenerateSyntheticProperty)
                {
#>
        private <#=relation.RelatedModelTypeName#> <#=relation.FieldName#>;

<#  
                    foreach (var attr in GlobalContainer.Settings.SyntheticProperties.CustomAttributes)
                    {
#>
        [<#=attr#>]
<#                       
                    }
                    if (oneToOneRelation.IsSyntheticPropertyTypeRequired && !string.IsNullOrEmpty(GlobalContainer.Settings.NotNullAttribute) && GlobalContainer.Settings.SyntheticProperties.AddNotNullAttribute)
                    {
#>
        [<#=GlobalContainer.Settings.NotNullAttribute#>]
<#
                    }
                    if (!string.IsNullOrEmpty(oneToOneRelation.SyntheticPropertyMaxLength) && !string.IsNullOrEmpty(GlobalContainer.Settings.LengthAttribute) && GlobalContainer.Settings.SyntheticProperties.AddLengthAttribute)
                    {
#>
        [<#=GlobalContainer.Settings.LengthAttribute#>(<#=oneToOneRelation.SyntheticPropertyMaxLength#>)]
<#
                    }
					if(relation.Property == null)
					{
#>
        public virtual <#=oneToOneRelation.SyntheticPropertyTypeName#> <#=oneToOneRelation.SyntheticPropertyName#> { get; <#=GlobalContainer.Settings.Strict ? "protected " : ""#>set; }
<#
					}
					else
					{
#>
		public virtual <#=oneToOneRelation.SyntheticPropertyTypeName#> <#=oneToOneRelation.SyntheticPropertyName#> 
		{ 
			get { return <#=oneToOneRelation.SyntheticFieldName#> != default(<#=oneToOneRelation.SyntheticPropertyTypeName#>) || <#=oneToOneRelation.PropertyName#> == null ? <#=oneToOneRelation.SyntheticFieldName#> : <#=oneToOneRelation.PropertyName#>.<#=oneToOneRelation.RelatedModelIdPropertyName#>; } 
			<#=GlobalContainer.Settings.Strict ? "protected " : ""#>set { <#=oneToOneRelation.SyntheticFieldName#> = value; }
		}

		private <#=oneToOneRelation.SyntheticPropertyTypeName#> <#=oneToOneRelation.SyntheticFieldName#>;
<#
					}    
                }
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
					if(!oneToOneRelation.ExistsSetMethod)
					{
#>

		public virtual void <#=oneToOneRelation.SetMethodName #>(<#=oneToOneRelation.RelatedModelTypeName #> <#=oneToOneRelation.ParameterName #>)
        {
			this.SetOneToOne(o => o.<#=oneToOneRelation.PropertyName #>, <#=oneToOneRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
					if (!oneToOneRelation.ExistsUnsetMethod)
					{
#>

        public virtual void <#=oneToOneRelation.UnsetMethodName #>()
        {
			this.UnsetOneToOne(o => o.<#=oneToOneRelation.PropertyName #>, o => o.<#=relation.PathInRelatedModel #>);
        }	
<#
					}
                }
                break;
        }
#>

		#endregion

<#
	}
    if (GlobalContainer.Settings.SyntheticProperties.Generate)
    {
#>

		private void SetField<T, TSynth>(ref T field, T vatue, ref TSynth synthField)
        {
            field = vatue;
            synthField = default(TSynth);
        }
<#  
    }
#>
	}
}
<#
	manager.EndBlock();
}
manager.Process(true);


globalWatch.Stop();
VSHelper.Warning(string.Format("T4FluentNH finished in {0} ms.", globalWatch.ElapsedMilliseconds)); 


#>

namespace FluentNHibernate.Automapping
{
    internal static class EntityExtensions
    {
        private static void AddIfNotExist<T>(ICollection<T> collection, T item)
        {
            if (!collection.Contains(item))
                collection.Add(item);
        }

        private static void RemoveIfExist<T>(ICollection<T> collection, T item)
        {
            if (collection.Contains(item))
                collection.Remove(item);
        }

        public static PropertyInfo GetPropertyInfo<TSource, TProperty>(TSource source, Expression<Func<TSource, TProperty>> propertyLambda)
        {
            var type = typeof(TSource);

            var member = propertyLambda.Body as MemberExpression;
            if (member == null)
                throw new ArgumentException(string.Format(
                    "Expression '{0}' refers to a method, not a property.",
                    propertyLambda));

            var propInfo = member.Member as PropertyInfo;
            if (propInfo == null)
                throw new ArgumentException(string.Format(
                    "Expression '{0}' refers to a field, not a property.",
                    propertyLambda.ToString()));

            if (type != propInfo.ReflectedType &&
                !type.IsSubclassOf(propInfo.ReflectedType))
                throw new ArgumentException(string.Format(
                    "Expresion '{0}' refers to a property that is not from type {1}.",
                    propertyLambda.ToString(),
                    type));

            return propInfo;
        }

        public static void AddOneToMany<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, Action<TMany>>> removeManyExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var itemOwner = oneExpr.Compile()(many);
            var entityOwnerPropInfo = GetPropertyInfo(many, oneExpr);

            if (collection.Contains(many)) return;
            if (itemOwner != null)
                removeManyExpr.Compile()(itemOwner)(many);
            entityOwnerPropInfo.SetValue(many, one);
            collection.Add(many);

            /*
            if (Locations.Contains(location)) return;
            if (location.User != null)
                location.User.RemoveLocation(location);
            location.User = this;
            Locations.Add(location);
            */
        }

        public static void RemoveOneToMany<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> entityExpr
            )
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var entityOwnerPropInfo = GetPropertyInfo(many, entityExpr);

            if (!collection.Contains(many)) return;
            collection.Remove(many);
            entityOwnerPropInfo.SetValue(many, null);

            /*
            if (!Locations.Contains(location)) return;
            Locations.Remove(location);
            location.User = null;
            */
        }

        public static void SetManyToOne<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr, TOne newOne,
            Expression<Func<TOne, Action<TMany>>> removeManyExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyExp)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var one = oneExpr.Compile()(many);
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyExp.Compile()(newOne);

            if (Equals(one, newOne)) return;
            if (one != null)
                removeManyExpr.Compile()(one)(many);
            onePropInfo.SetValue(many, newOne);
            AddIfNotExist(manyList, many);

            /*
            if (User == user) return;
            if(User != null)
                User.RemoveLocation(this);
            User = user;
            AddIfNotExist(user.Locations, this);
            */
        }

        public static void UnsetManyToOne<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var one = oneExpr.Compile()(many);
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(one);

            if (one == null) return;
            RemoveIfExist(manyList, many);
            onePropInfo.SetValue(many, null);
            /*
            if(User == null) return;
            RemoveIfExist(User.Locations, this);
            User = null;*/
        }

        public static void AddManyToMany<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);

            AddIfNotExist(manyList, many);
            AddIfNotExist(many2List, many2);
            /*
            camera.Locations.AddIfNotExist(this);
            Cameras.AddIfNotExist(camera);*/
        }

        public static void RemoveManyToMany<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);

            RemoveIfExist(manyList, many);
            RemoveIfExist(many2List, many2);
            /*
            RemoveIfExist(camera.Locations, this);
            RemoveIfExist(Cameras, camera);*/
        }

        public static void SetOneToOne<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr, TOne2 one2,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TOne2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var oneInOne2 = oneExpr.Compile()(one2);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);
            var currentOne2 = one2Expr.Compile()(one);
            var currentOne2PropInfo = GetPropertyInfo(one, one2Expr);

            if (oneInOne2 != null)
                oneInOne2.UnsetOneToOne(one2Expr, oneExpr);
            oneInOne2PropInfo.SetValue(one2, one);
            if (currentOne2 != null)
                currentOne2.UnsetOneToOne(oneExpr, one2Expr);
            currentOne2PropInfo.SetValue(one, one2);
            /*
             if(MerryWith.MerriedWith != null)
               MerryWith.UnSet
             MerryWith.MerriedWith = this;
             if(MerryWith != null)
               UnSet
             MerriedWith = value;
             */
        }

        public static void UnsetOneToOne<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TOne2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var one2 = one2Expr.Compile()(one);
            var one2PropInfo = GetPropertyInfo(one, one2Expr);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);

            if (one2 == null) return;
            oneInOne2PropInfo.SetValue(one2, null);
            one2PropInfo.SetValue(one, null);

            /*
            if (MerriedWith == null) return;
            MerriedWith.MerriedWith = null;  
            MerriedWith = null;
             */
        }

        private static object GetDefault(Type type)
        {
            if (type.IsValueType)
            {
                return Activator.CreateInstance(type);
            }
            return null;
        }
    }
}

<#+
public enum ModelRelationType
{
	None,
	OneToOne,
	OneToMany,
	ManyToOne,
	ManyToMany
}

public enum CollectionMapType
{
    Unknown = 0,
    Set,
    Bag,
    List
}

public enum AssociationType
{
    Unknown = 0,
    Unidirectional,
    Bidirectional
}

public abstract class ModelRelation
{
	#region Basic props

	public virtual ModelRelationType Type { get { return ModelRelationType.None; } }

	public string RelatedModelTypeFullName { get; set; }

	public string PathInRelatedModel { get; set; }

	public AssociationType AssociationType { get; set; }

	public string KeyColumn { get; set; }

	#endregion


	public DomainModelWrapper Model { get; set; }

	public DomainModelWrapper RelatedModel { get; set; }

	public EntityType RelatedModelEntityType { get; set; }

	public string FieldName { get; set; }

	public string ParameterName { get; set; }

    public string RelatedModelIdPropertyName
    {
        get { return RelatedModelEntityType.IdentifierPropertyName; }
    }

    public bool UseFullNamespaceForRelatedModelType
    {
        get
        {
            return !(
                RelatedModel != null &&
                (
                    Model.Namespace.FullName == RelatedModel.Namespace.FullName ||
                    GlobalContainer.KnownNamespaces.Contains(RelatedModel.Namespace.FullName)
                    )
                );
        }
    }

    public string RelatedModelTypeName //Is the same as RelatedModelTypeFullName when the related type is not is the same namespace
    {
        get
        {
            return RelatedModel != null
                ? (UseFullNamespaceForRelatedModelType ? RelatedModel.FullName : RelatedModel.Name)
                : (UseFullNamespaceForRelatedModelType ? RelatedModelTypeFullName : RelatedModelTypeFullName.Split('.').Last());
        }
    } 

	public CodeProperty Property { get; set; }

    public string PropertyName
    {
        get
        {
            return Property == null
                ? Model.Name
                : Property.Name;
        }
    }

    public string SingularPropertyName { get { return GlobalContainer.Singularize(PropertyName); } }

	
}

public class NoneModelRelation : ModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.None; } }
}

public abstract class OneModelRelation : ModelRelation
{
	public bool GenerateSyntheticProperty { get; set; }

	public string SyntheticPropertyName { get; set; }

	public string SyntheticPropertyTypeName { get; set; }

	public string SyntheticFieldName { get; set; }

	public string SyntheticPropertyMaxLength { get; set; }

	public bool IsSyntheticPropertyTypeRequired { get; set; }

	//Only set for bidirection relation
	public bool ExistsSetMethod { get; set; }

	public string SetMethodName { get; set; }

	public bool ExistsUnsetMethod { get; set; }

	public string UnsetMethodName { get; set; }
}

public class OneToOneModelRelation : OneModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.OneToOne; } }
}

public class ManyToOneModelRelation : OneModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.ManyToOne; } }

	public string RelatedTypeRemoveMethodName { get; set; }
}

public abstract class CollectionModelRelation : ModelRelation
{
	#region Basic props

	public string CollectionType { get; set; }

	public CollectionMapType CollectionMapType { get; set; }

	#endregion

	public string FieldCollectionType { get; set; }

    //Only set for bidirection relation

	public bool ExistsAddMethod { get; set; }

	public string AddMethodName { get; set; }

	public bool ExistsRemoveMethod { get; set; }

	public string RemoveMethodName { get; set; }
}

public class OneToManyModelRelation : CollectionModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.OneToMany; } }
}

public class ManyToManyModelRelation : CollectionModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.ManyToMany; } }
}

[Serializable]
public class EntityProjectItem
{
	[System.Xml.Serialization.XmlIgnoreAttribute]
    private readonly List<ProjectItem> _entityProjectItems = new List<ProjectItem>();
	[System.Xml.Serialization.XmlIgnoreAttribute]
	private readonly List<ProjectItem> _overrideProjectItems = new List<ProjectItem>();
	[System.Xml.Serialization.XmlIgnoreAttribute]
	private ProjectItem _generatedItem;

	public EntityProjectItem() {}

    public EntityProjectItem(string fullName)
    {
        EntityFullName = fullName;
        OverrideFilePaths = new List<string>();
		EntityFilePaths = new List<string>();
    }

	public string EntityFullName { get; set; }

    public List<string> EntityFilePaths { get; set; }

	public List<string> OverrideFilePaths { get; set; }

	public string GeneratedFilePath { get; set; }

	[System.Xml.Serialization.XmlIgnoreAttribute]
	public string GeneratedFileAbsoultePath { get { return _generatedItem.FileNames[0]; } }

    public void SetGeneratedFile(ProjectItem pItem)
    {
        _generatedItem = pItem;
        GeneratedFilePath = GlobalContainer.VSHelper.GetRelativePathToCurrentProject(pItem);
    }

    public void AddEntityFile(ProjectItem pItem)
    {
        _entityProjectItems.Add(pItem);
        EntityFilePaths.Add(GlobalContainer.VSHelper.GetRelativePathToCurrentProject(pItem));
    }

	public void AddOverrideFile(ProjectItem pItem)
    {
        _overrideProjectItems.Add(pItem);
        OverrideFilePaths.Add(GlobalContainer.VSHelper.GetRelativePathToCurrentProject(pItem));
    }

    public bool IsDirty()
    {
        if (string.IsNullOrEmpty(GeneratedFilePath)) return true;

		//Get EntityProjectItem instance from the generated file
        var genFileText = File.ReadAllText(GetFullPathByRelative(GeneratedFilePath));
        var match = Regex.Match(genFileText, "//(<EntityProjectItem.*</EntityProjectItem>)");
        if (!match.Success) return true;
        var xml = match.Groups[1].Value;
		var serializer = new System.Xml.Serialization.XmlSerializer(typeof(EntityProjectItem));
		EntityProjectItem result;

		using (var reader = new StringReader(xml))
		{
			result = (EntityProjectItem)serializer.Deserialize(reader);
		}

		//Check if any of the files was renamed or deleted
        if (!AreEqual(result)) return true;

		//Check if there is any override or entity class that has greater LastWriteTime than the generated file
        var genWriteTime = File.GetLastWriteTime(GetFullPathByRelative(GeneratedFilePath));
        return _entityProjectItems.Union(_overrideProjectItems)
            .Any(pItem =>
            {
                var absPath = pItem.FileNames[0];
                if (File.GetLastWriteTime(absPath) > genWriteTime) return true; //was modified
                if (!pItem.Saved) return true; //was modified but not yet saved
                return false;
            });
    }

    private string GetFullPathByRelative(string relative)
    {
        return Path.Combine(Path.GetDirectoryName(GlobalContainer.VSHelper.CurrentProject.FullName), relative);
    }

    public bool AreEqual(EntityProjectItem item)
    {
        return (
            item.GeneratedFilePath == GeneratedFilePath &&
            item.EntityFullName == EntityFullName &&

            item.EntityFilePaths.Count == EntityFilePaths.Count &&
            item.EntityFilePaths.All(o => EntityFilePaths.Contains(o)) &&
            EntityFilePaths.All(o => item.EntityFilePaths.Contains(o)) &&

            item.OverrideFilePaths.Count == OverrideFilePaths.Count &&
            item.OverrideFilePaths.All(o => OverrideFilePaths.Contains(o)) &&
            OverrideFilePaths.All(o => item.OverrideFilePaths.Contains(o))
        );
    }

    public string Serialize()
    {
        var xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(EntityProjectItem));
        var settings = new System.Xml.XmlWriterSettings
        {
            OmitXmlDeclaration = true,
            Indent = false
        };
	    using(var strWriter = new StringWriter())
		using(var writer = System.Xml.XmlWriter.Create(strWriter, settings))
		{
			xmlSerializer.Serialize(writer, this);
			return strWriter.ToString();
		}
    }
}

public static class GlobalContainer
{
	public static CSharpCodeProvider CSharpCodeProvider = new CSharpCodeProvider();

    public static VisualStudioHelper VSHelper;

    public static XmlSettings Settings;

    public static Dictionary<string, List<ModelRelation>> GlobalModelRelations;

    public static Dictionary<string, DomainModelWrapper> DomainClasses;

    public static HashSet<string> KnownNamespaces;

    public static Dictionary<string, Dictionary<string, ModelRelation>> Overrides; //Dict<typeFullName, Dict<propName, Relation>>

    public static Dictionary<string, List<CodeClass2>> ProjectTypes;

    public static IEnumerable<ProjectItem> ProjectItems;

	public static HashSet<ProjectItem> DomainProjectItems;

    public static Dictionary<string, EntityProjectItem> EntityProjectItems;

    public static Dictionary<string, Dictionary<string, CodeProperty>> Components; //Dict<typeFullName, PropName, PropTypefullName>


	public static string Singularize(string name)
	{
	    foreach (var singularize in Settings.Singularization
			.Where(singularize => Regex.IsMatch(name, singularize.Pattern)))
	    {
	        return Regex.Replace(name, singularize.Pattern, singularize.Replace);
	    }

	    return VSHelper.Singularize(name);
	}

    public static void Reset()
    {
        GlobalModelRelations.Clear();
        DomainClasses.Clear();
		Overrides.Clear();
		EntityProjectItems.Clear();
		Components.Clear();
		DomainProjectItems.Clear();
    }

    public static EntityType GetEntityType(CodeClass2 codeClass, bool throwIfNotFound)
    {
        return Settings.GetEntityType(VSHelper, codeClass, throwIfNotFound);
    }

	public static void AddGlobalModelRelation(string typeFullName, ModelRelation relation)
    {
        if(!GlobalModelRelations.ContainsKey(typeFullName))
            GlobalModelRelations.Add(typeFullName, new List<ModelRelation>());
        GlobalModelRelations[typeFullName].Add(relation);
    }

	static GlobalContainer()
	{
		GlobalModelRelations = new Dictionary<string, List<ModelRelation>>();
		DomainClasses = new Dictionary<string, DomainModelWrapper>();
		Overrides = new Dictionary<string, Dictionary<string, ModelRelation>>();
		ProjectTypes = new Dictionary<string, List<CodeClass2>>();
		Components = new Dictionary<string, Dictionary<string, CodeProperty>>();
	    EntityProjectItems = new Dictionary<string, EntityProjectItem>();
	    DomainProjectItems = new HashSet<ProjectItem>();
	}
}


public class DomainModelWrapper
{
	public DomainModelWrapper()
	{
		MappedProperties = new Dictionary<string, CodeProperty>();
		RelatedModels = new List<ModelRelation>();
	}
	
	#region Settable props

	public string SettingsXml { get; set; }

	public CodeClass2 CodeClass { get; set; }

	public ProjectItem ProjectItem { get; set; }

	public bool WasModified { get; set; }

	public List<ModelRelation> RelatedModels { get; set; }

	#endregion


	public Dictionary<string, CodeProperty> MappedProperties { get; private set; }

	public EntityType EntityType { get; private set; }

    public string FullClassName
    {
        get
        {
            return CodeClass.IsGeneric
                ? Name + string.Format("<{0}>", string.Join(", ", GlobalContainer.VSHelper.GetGenericAgruments(FullName)))
                : Name;
        }
    }

    public string FileName
    {
        get
        {
            return CodeClass.IsGeneric
                ? string.Format("{0}({1})", Name, string.Join("_", GlobalContainer.VSHelper.GetGenericAgruments(FullName)))
                : Name;
        }
    }

	public string Name { get { return CodeClass.Name; } }

	public CodeNamespace Namespace { get { return CodeClass.Namespace; } }

	public string FullName { get { return CodeClass.FullName; } }

	public void Merge(DomainModelWrapper wrapper)
    {
		if(FullName != wrapper.FullName)
			throw new Exception("Cannot merge two ModelWrappers with different types");
		foreach(var pair in wrapper.MappedProperties)
        {
			if(MappedProperties.ContainsKey(pair.Key))
            {
				GlobalContainer.VSHelper.Warning(string.Format("Cannot add an existing property! Entity {0}, duplicate property {1}", FullName, pair.Key));
				continue;
            }
			MappedProperties.Add(pair.Key, pair.Value);
        }
		foreach(var relation in wrapper.RelatedModels)
        {
			if(RelatedModels.Contains(relation)) //TODO: fix this
            {
				GlobalContainer.VSHelper.Warning(string.Format("Cannot add an existing relation! Entity {0}, duplicate relation {1}", FullName, relation.RelatedModelTypeName));
				continue;
            }
			RelatedModels.Add(relation);
        }
    }


	public void Initialize()
	{
		if(!WasModified) return;
		GlobalContainer.VSHelper.SetAsPartial(CodeClass);
	    EntityType = GlobalContainer.GetEntityType(CodeClass, true);

		//Setup global relations
	    if (GlobalContainer.GlobalModelRelations.ContainsKey(FullName))
	    {
	        foreach (var globalRelation in GlobalContainer.GlobalModelRelations[FullName])
	        {
				SetupRelation(globalRelation);
	            RelatedModels.Add(globalRelation);
	        }
	    }

		//Editing properties 
		//VSHelper.Warning(CodeClass.FullName + " "+  VSHelper.GetProperties(CodeClass).Count().ToString());
		//VSHelper.Warning(CodeClass.FullName);
		foreach(var prop in GlobalContainer.VSHelper.GetProperties(CodeClass))
		{
		    var prop2 = prop as CodeProperty2;
			//dont touch overrides and abstract props           
            if(prop2 != null && prop2.OverrideKind != vsCMOverrideKind.vsCMOverrideKindOverride && prop2.OverrideKind != vsCMOverrideKind.vsCMOverrideKindAbstract)
			    GlobalContainer.VSHelper.SetAsVirtual(prop2);

			if (!GlobalContainer.VSHelper.IsNHibernateProperty(prop) || GlobalContainer.Settings.IgnoreTypes.Contains(prop.Type.AsFullName) ||
                prop.Type.TypeKind == vsCMTypeRef.vsCMTypeRefOther) //Generic type
		        continue;
			
			if (GlobalContainer.VSHelper.IsEnumerable(prop.Type) && GlobalContainer.VSHelper.IsGeneric(prop.Type))
			{
			    var itemType = GlobalContainer.VSHelper.GetGenericAgruments(prop.Type).First();
			    if (GlobalContainer.Settings.IgnoreTypes.Contains(itemType)) continue;
			}

			MappedProperties.Add(prop.Name, prop);
			
			EditMappedProperty(prop);
				
		}

	    //Define methods as virtual
		foreach(var method in GlobalContainer.VSHelper.GetMethods(CodeClass))
        {
            if(method.Access != vsCMAccess.vsCMAccessPrivate)
			    method.OverrideKind = vsCMOverrideKind.vsCMOverrideKindVirtual;
        }

		ProjectItem.Save(); //Save the item
    }

    private void SetupRelation(ModelRelation relation)
    {
		relation.Model = this;
        if (relation.Type == ModelRelationType.None) return;

        var relatedType = GlobalContainer.DomainClasses.ContainsKey(relation.RelatedModelTypeFullName)
            ? GlobalContainer.DomainClasses[relation.RelatedModelTypeFullName]
            : null; //external type
        relation.RelatedModel = relatedType;
		relation.RelatedModelEntityType = relatedType != null
				        ? GlobalContainer.GetEntityType(relatedType.CodeClass, true)
				        : GlobalContainer.Settings.GetEntityType(GlobalContainer.Settings.GetExternalType(relation.RelatedModelTypeFullName), true);
		relation.FieldName = GlobalContainer.VSHelper.GetFieldName(relation.PropertyName);
        relation.ParameterName = GlobalContainer.Singularize(GlobalContainer.VSHelper.FirstCharToLower(relation.PropertyName));
        if (!GlobalContainer.CSharpCodeProvider.IsValidIdentifier(relation.ParameterName))
            relation.ParameterName = "@" + relation.ParameterName;

        switch (relation.Type)
        {
            case ModelRelationType.OneToMany:
			case ModelRelationType.ManyToMany:
                var collectionRelation = (CollectionModelRelation) relation;
                collectionRelation.FieldCollectionType = GlobalContainer.VSHelper.GetValidNHibernteEnumerableInterface(relation.Property,
                    collectionRelation.CollectionType, GlobalContainer.Settings.Strict, relation.RelatedModelTypeName);
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
                    collectionRelation.AddMethodName = "Add" + collectionRelation.SingularPropertyName;
					collectionRelation.ExistsAddMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
						.Any(o => o.Name == collectionRelation.AddMethodName && 
							o.Parameters.Count == 1 &&
							o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);

					collectionRelation.RemoveMethodName = "Remove" + collectionRelation.SingularPropertyName;
					collectionRelation.ExistsRemoveMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
						.Any(o => o.Name == collectionRelation.RemoveMethodName && 
							o.Parameters.Count == 1 &&
							o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);
                }
                break;

			case ModelRelationType.ManyToOne:
			case ModelRelationType.OneToOne:
				var oneRelation = (OneModelRelation) relation;
                oneRelation.SetMethodName = "Set" + relation.PropertyName;
				oneRelation.ExistsSetMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
						.Any(o => o.Name == oneRelation.SetMethodName && 
							o.Parameters.Count == 1 &&
							o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);

				oneRelation.UnsetMethodName = "Unset" + relation.PropertyName;
				oneRelation.ExistsUnsetMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
						.Any(o => o.Name == oneRelation.UnsetMethodName && o.Parameters.Count == 0);

                if (relation.Type == ModelRelationType.ManyToOne)
                {
                    var manyToOne = (ManyToOneModelRelation) relation;
					if(!string.IsNullOrEmpty(relation.PathInRelatedModel))
						manyToOne.RelatedTypeRemoveMethodName = "Remove" + GlobalContainer.Singularize(relation.PathInRelatedModel);
                }
	
				if(GlobalContainer.Settings.SyntheticProperties.Generate)
				{
				    
					var syntheticPropValueType = GlobalContainer.VSHelper.IsValueType(relation.RelatedModelEntityType.IdentifierPropertyType);
					oneRelation.SyntheticPropertyTypeName = GlobalContainer.VSHelper.SimplifyTypeName(relation.RelatedModelEntityType.IdentifierPropertyType);
				    oneRelation.IsSyntheticPropertyTypeRequired =
				        relation.Property != null &&
				        GlobalContainer.VSHelper.GetAttribute(relation.Property.Attributes, GlobalContainer.Settings.NotNullAttribute) != null;
					if (!oneRelation.IsSyntheticPropertyTypeRequired && syntheticPropValueType)
						oneRelation.SyntheticPropertyTypeName += "?";
					oneRelation.SyntheticPropertyName = !string.IsNullOrEmpty(relation.KeyColumn)
						? relation.KeyColumn
						: relation.RelatedModelEntityType.KeyColumnPrefix + relation.PropertyName + relation.RelatedModelEntityType.KeyColumnPostfix;
					oneRelation.SyntheticFieldName = GlobalContainer.VSHelper.GetFieldName(oneRelation.SyntheticPropertyName);
					oneRelation.SyntheticPropertyMaxLength = relation.RelatedModelEntityType.GetIdentifierLength(relation.RelatedModelTypeFullName);
				    oneRelation.GenerateSyntheticProperty =
				        GlobalContainer.VSHelper.GetInheritedProperties((CodeType) CodeClass)
				            .All(o => o.Name != oneRelation.SyntheticPropertyName); //Check if is already defined
				}
                break;
        }
    }

    private ModelRelation GetRelation(CodeProperty prop)
	{
	    if (GlobalContainer.Overrides.ContainsKey(FullName) && GlobalContainer.Overrides[FullName].ContainsKey(prop.Name))
	        return GlobalContainer.Overrides[FullName][prop.Name];

	    var one = !(GlobalContainer.VSHelper.IsEnumerable(prop.Type) && GlobalContainer.VSHelper.IsGeneric(prop.Type));
        var typeFullName = one
            ? prop.Type.CodeType.FullName
            : GlobalContainer.VSHelper.GetGenericAgruments(prop.Type).First();

	    var externalType = GlobalContainer.Settings.IsExternalType(typeFullName);

        //External type cannot have a bidirectional association
	    if (!externalType)
	    {
	        if(!GlobalContainer.ProjectTypes.ContainsKey(typeFullName))
		    {
				if(!typeFullName.StartsWith("System."))
					GlobalContainer.VSHelper.Warning(String.Format("Type {0} does not exists in the current project, skiping relation for property '{1}' in '{2}'", 
					typeFullName, prop.Name, FullClassName));
		        return new NoneModelRelation();
		    }
            //Skip further processing if the related type is not an entity
	        if (!GlobalContainer.ProjectTypes[typeFullName].Any(o => o.IsDerivedFrom[GlobalContainer.Settings.BaseEntityType]))
	        {
	            return new NoneModelRelation();
	        }

            //Check for Bidirectional association
		    foreach(var cls in GlobalContainer.ProjectTypes[typeFullName])
            {
			    foreach(var p in GlobalContainer.VSHelper.GetProperties(cls, true))
                {
				    if(GlobalContainer.VSHelper.IsEnumerable(p.Type) && 
						GlobalContainer.VSHelper.IsGeneric(p.Type) && 
						GlobalContainer.VSHelper.GetGenericAgruments(p.Type).First() == FullName && 
						prop.Name == cls.Name) //generic collection
				    {
				        //VSHelper.Warning(cls.Name +  " " + p.Name  + " " + typeFullName + " " + (one ?  "OM" : "MM"));
                        if (one)
                        {
                            return new ManyToOneModelRelation
                            {
                                RelatedModelTypeFullName = typeFullName,
                                Property = prop,
                                PathInRelatedModel = p.Name,
                                AssociationType = AssociationType.Bidirectional
                            };
                        }
				        return new ManyToManyModelRelation
				        {
				            RelatedModelTypeFullName = typeFullName,
				            CollectionType = GlobalContainer.VSHelper.GetPropertyType(prop),
				            Property = prop,
				            PathInRelatedModel = p.Name,
				            AssociationType = AssociationType.Bidirectional
				        };
				    }
                    if (p.Type.AsFullName != FullName) continue;
                    if (one && 
                        (
                            //by default convention one to one is not generated
                            GlobalContainer.VSHelper.GetAttribute(prop.Attributes, "T4FluentNH.Attributes.AsOneToOneAttribute") == null ||
                            //property must be the same when one to one is defined on the same type
                            (typeFullName == FullName && p.Name != prop.Name)
                        )
                    )
                    {
                        continue;
                    }

                    if (one)
                    {
                        return new OneToOneModelRelation
                        {
                            RelatedModelTypeFullName = typeFullName,
                            Property = prop,
                            PathInRelatedModel = p.Name,
                            AssociationType = AssociationType.Bidirectional
                        };
                    }

                    //VSHelper.Warning(cls.Name +  " " + p.Name  + " " + typeFullName + " " + (one ?  "OO" : "MO"));
                    return new OneToManyModelRelation
                    {
                        RelatedModelTypeFullName = typeFullName,
                        CollectionType = GlobalContainer.VSHelper.GetPropertyType(prop),
                        Property = prop,
                        PathInRelatedModel = p.Name,
                        AssociationType = AssociationType.Bidirectional
                    };
                }
            }
	    }


        //Unidirectional association - By default unidirectional associations are oneToMany and manyToOne
		//VSHelper.Warning(typeFullName +  " " + prop.Name  + " " + (one ?  "MO" : "MM"));
        //manyToOne
	    if (one)
	    {
	        return new ManyToOneModelRelation
	        {
	            RelatedModelTypeFullName = typeFullName,
	            Property = prop,
	            PathInRelatedModel = null,
	            AssociationType = AssociationType.Unidirectional
	        };
	    }

        //oneToMany - in this case we have to add two relations for both sides
		/*
	    AddGlobalModelRelation(typeFullName, new ModelRelation
	    {
	        Type = ModelRelationType.ManyToOne,
	        RelatedModelType = FullName,
	        ListType = null,
	        Property = null,
	        PathInRelatedModel = prop.Name,
	        AssociationType = AssociationType.Unidirectional
	    });*/

	    return new OneToManyModelRelation
	    {
	        RelatedModelTypeFullName = typeFullName,
	        CollectionType = GlobalContainer.VSHelper.GetPropertyType(prop),
	        Property = prop,
	        PathInRelatedModel = null,
	        AssociationType = AssociationType.Unidirectional
	    };
	}

    private void EditMappedManyRelation(CodeProperty prop, CollectionModelRelation relation)
    {
		//Gtt.Warning(string.Format("{0} - {1} = {2}", FullName, listType, relation));
        GlobalContainer.VSHelper.SetAsPublic(prop);
		var listImplType = GlobalContainer.VSHelper.GetEnumerableImplType(prop);
		if (listImplType == null)
		{
		    var colMapType = relation.CollectionMapType;
		    if (colMapType == CollectionMapType.Unknown)
		    {
		        GlobalContainer.VSHelper.Warning(string.Format("CollectionMapType is not set for property '{0}' in class '{1}'",
		            prop.Name, Name));
		        colMapType = GlobalContainer.Settings.DefaultCollectionMapType;
		    }
		    switch (colMapType)
		    {
		        case CollectionMapType.Set:
		        case CollectionMapType.Bag:
		            listImplType = "HashSet";
		            break;
		        case CollectionMapType.List:
		            listImplType = "List";
		            break;
		    }
		}

		var newType = GlobalContainer.VSHelper.GetValidNHibernteEnumerableInterface(prop, listImplType, GlobalContainer.Settings.Strict);
		GlobalContainer.VSHelper.SetPropertyType(prop, newType);
		var body = string.Format(@"
		{{
			{0}
			{1}
		}}",
		string.Format("get {{ return {0} ?? ({0} = new {1}<{2}>()); }}", GlobalContainer.VSHelper.GetFieldName(prop.Name),
		        listImplType, GlobalContainer.VSHelper.GetClassName(relation.RelatedModelTypeFullName)),
		string.Format("{0}set {{ {1} = value; }}", GlobalContainer.Settings.Strict ? "protected " : "",
		        GlobalContainer.VSHelper.GetFieldName(prop.Name)));
		GlobalContainer.VSHelper.SetPropertyBody(prop, body);	
    }

    private void EditMappedOneRelation(CodeProperty prop, OneModelRelation relation)
    {
        if (relation.GenerateSyntheticProperty)
        {
		var body = string.Format(@"
		{{
			{0}
			{1}
		}}",
			string.Format("get {{ return {0}; }}", relation.FieldName),
			string.Format("{2}set {{ SetField(ref {0}, value, ref {1}); }}", 
				relation.FieldName,
                relation.SyntheticFieldName,
                (GlobalContainer.Settings.Strict ? "protected internal " : "")));
			GlobalContainer.VSHelper.SetPropertyBody(prop, body);	
        }
        else
        {
            GlobalContainer.VSHelper.SetSetter(prop, GlobalContainer.Settings.Strict ? "protected internal set;" : "set;");
        }
    }

    private void EditMappedComponent(CodeProperty prop)
    {
	    var body = string.Format(@"
		{{
			{0}
			{1}
		}}", string.Format("get {{ return {0} ?? ({0} = new {1}()); }}", GlobalContainer.VSHelper.GetFieldName(prop.Name), prop.Type.CodeType.Name),
			string.Format("{0}set {{ {1} = value; }}", GlobalContainer.Settings.Strict ? "protected " : "", GlobalContainer.VSHelper.GetFieldName(prop.Name)));
        GlobalContainer.VSHelper.SetPropertyBody(prop, body);
    }

	private void EditMappedProperty(CodeProperty prop)
    {
        var relation = GetRelation(prop);
		SetupRelation(relation);
	    if (relation.Type != ModelRelationType.None)
	    {
	        var colleactionRelaton = relation as CollectionModelRelation;
	        if(colleactionRelaton != null)
	            EditMappedManyRelation(prop, colleactionRelaton);
	        
			var oneRelation = relation as OneModelRelation;
			if(oneRelation != null)
				EditMappedOneRelation(prop, oneRelation);

			RelatedModels.Add(relation);
	    }

        //Component
	    if (GlobalContainer.Components.ContainsKey(FullName) && GlobalContainer.Components[FullName].ContainsKey(prop.Name))
	    {
	        EditMappedComponent(prop);
	    }
    }
}

#>
<#+

    public class EntityType
    {
        public string DerivedFromType { get; set; }

        public string KeyColumnPrefix { get; set; }

        public string KeyColumnPostfix { get; set; }

        public string IdentifierPropertyType { get; set; }

		public string IdentifierPropertyName { get; set; }

        public string IdentifierLength { get; set; }

        public Dictionary<string,string> CustomIdentifierLengths { get; set; }

        public string GetIdentifierLength(string typeFullName)
        {
            if (CustomIdentifierLengths.ContainsKey(typeFullName))
                return CustomIdentifierLengths[typeFullName];
            return IdentifierLength;
        }
    }

    public class ExternalType
    {
        public string FullName { get; set; }

        public string DerivedFromType { get; set; }

    }

	public class Singularize
    {
        public string Pattern { get; set; }

        public string Replace { get; set; }

    }

    public class SyntheticProperties
    {
        public bool Generate { get; set; }

        public string Comment { get; set; }

        public bool AddNotNullAttribute { get; set; }

        public bool AddLengthAttribute { get; set; }

        public List<string> CustomAttributes { get; set; } 
    }

	public class GenerateMetadata
    {
        public bool Relations { get; set; }
    }

    public class XmlSettings
    {
        public static XmlSettings Load(string path)
        {
            if(!File.Exists(path))
                throw new FileNotFoundException(string.Format("Missing settings at: '{0}'", path));

            var xElement = XElement.Load(path);
            
            var settings = new XmlSettings
            {
                BaseEntityType = xElement.XPathSelectElement("/BaseEntityType").Value,
                Strict = xElement.XPathSelectElement("/Strict").Value.ToUpperInvariant() == "TRUE",
                DefaultCollectionMapType = (CollectionMapType)Enum.Parse(typeof(CollectionMapType), xElement.XPathSelectElement("/DefaultCollectionMapType").Value, true),
                SyntheticProperties = new SyntheticProperties
                {
                  AddLengthAttribute  = xElement.XPathSelectElement("/SyntheticProperties/AddLengthAttribute").Value.ToUpperInvariant() == "TRUE",
                  AddNotNullAttribute = xElement.XPathSelectElement("/SyntheticProperties/AddNotNullAttribute").Value.ToUpperInvariant() == "TRUE",
                  Comment = xElement.XPathSelectElement("/SyntheticProperties/Comment").Value,
                  Generate = xElement.XPathSelectElement("/SyntheticProperties/Generate").Value.ToUpperInvariant() == "TRUE",
                  CustomAttributes = xElement.XPathSelectElements("SyntheticProperties/CustomAttributes//CustomAttribute")
                    .Select(o => o.Value).ToList()
                },
                EntityTypes = xElement.XPathSelectElements("/EntityTypes//EntityType")
                .Select(o => new EntityType
                {
                    DerivedFromType = o.XPathSelectElement("DerivedFromType").Value,
                    KeyColumnPrefix = o.XPathSelectElement("KeyColumn/Prefix").Value,
                    KeyColumnPostfix = o.XPathSelectElement("KeyColumn/Postfix").Value,
                    IdentifierPropertyType = o.XPathSelectElement("IdentifierPropertyType").Value,
					IdentifierPropertyName = o.XPathSelectElement("IdentifierPropertyName").Value,
                    IdentifierLength = o.XPathSelectElement("IdentifierLength") != null 
                        ? o.XPathSelectElement("IdentifierLength").Value
                        : null,
                    CustomIdentifierLengths = o.XPathSelectElements("CustomIdentifierLengths//CustomIdentifierLength").Any()
                        ? o.XPathSelectElements("CustomIdentifierLengths//CustomIdentifierLength")
                            .ToDictionary(c => c.XPathSelectElement("Type").Value, c => c.XPathSelectElement("Length").Value)
                        : new Dictionary<string,string>()
                }).ToList(),
                ExternalTypes = new List<ExternalType>(xElement.XPathSelectElements("/ExternalTypes//ExternalType")
                    .Select(o => new ExternalType
                    {
                        DerivedFromType = o.XPathSelectElement("DerivedFromType").Value,
                        FullName = o.XPathSelectElement("FullName").Value,
                    })),
				Singularization = new List<Singularize>(xElement.XPathSelectElements("/Singularization//Singularize")
                    .Select(o => new Singularize
                    {
                        Pattern = o.XPathSelectElement("Pattern").Value,
                        Replace = o.XPathSelectElement("Replace").Value,
                    })),
				GenerateMetadata = new GenerateMetadata
				{
				  Relations  = xElement.XPathSelectElement("/GenerateMetadata/Relations").Value.ToUpperInvariant() == "TRUE"
				},
                IgnoreTypes = new HashSet<string>(xElement.XPathSelectElements("/IgnoreTypes//IgnoreType").Select(o => o.Value)),
                NotNullAttribute = xElement.XPathSelectElement("/NotNullAttribute").Value,
                LengthAttribute = xElement.XPathSelectElement("/LengthAttribute").Value,
            };
            if(string.IsNullOrEmpty(settings.BaseEntityType))
                throw new Exception("BaseEntityType is not set");
            return settings;
        }

        public List<EntityType> EntityTypes { get; set; }

        public EntityType GetEntityType(VisualStudioHelper vsHelper, CodeClass2 codeClass, bool throwIfNotFound)
        {
            var eType = EntityTypes.FirstOrDefault(o => codeClass.IsDerivedFrom[o.DerivedFromType] || vsHelper.ContainBaseType(codeClass, o.DerivedFromType));
            if(eType == null && throwIfNotFound)
                throw new Exception("EntityType for type " + codeClass.FullName + " does not exists");
            return eType;
        }

        public EntityType GetEntityType(ExternalType externalType, bool throwIfNotFound)
        {
            var eType = EntityTypes.FirstOrDefault(o => o.DerivedFromType == externalType.DerivedFromType);
            if(eType == null && throwIfNotFound)
                throw new Exception("EntityType that derives from type " + externalType.DerivedFromType + " does not exists");
            return eType;
        }

        public bool IsExternalType(string typeFullName)
        {
            return ExternalTypes.Any(o => o.FullName == typeFullName);
        }

        public ExternalType GetExternalType(string typeFullName)
        {
            return ExternalTypes.FirstOrDefault(o => o.FullName == typeFullName);
        }

        public string NotNullAttribute { get; set; }

        public string LengthAttribute { get; set; }
        
        public HashSet<string> IgnoreTypes { get; set; }

        public List<ExternalType> ExternalTypes { get; set; }

		public List<Singularize> Singularization { get; set; }

        public string BaseEntityType { get; set; }

        public CollectionMapType DefaultCollectionMapType { get; set; }

        public bool Strict { get; set; }

        public SyntheticProperties SyntheticProperties { get; set; }

        public GenerateMetadata GenerateMetadata { get; set; }

    }


#>
