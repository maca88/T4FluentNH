// <auto-generated />
// This file was generated by a T4 template.
// Don't change it directly as your change would get overwritten.  Instead, make changes
// to the .tt file (i.e. the T4 template) and save it to regenerate this file.

// Make sure the compiler doesn't complain about missing Xml comments





//----------------------
// <auto-generated>
//    Generated by T4FluentNH.
// </auto-generated>
//----------------------
// ReSharper disable All
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.CodeDom.Compiler;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using FluentNHibernate.Automapping;
using FluentNHibernate.Mapping;
using T4FluentNH.Metadata;
using NHibernate;
using NHibernate.Collection;
using NHibernate.Util;
using System.Threading.Tasks;


using FluentNHibernate.Conventions;
using FluentNHibernate.Conventions.Instances;

namespace T4FluentNH.Conventions
{
    public class ReadOnlyAttributeConvention : AttributePropertyConvention<ReadOnlyAttribute>
    {
        protected override void Apply(ReadOnlyAttribute attribute, IPropertyInstance instance)
        {
            if (attribute.IsReadOnly)
                instance.ReadOnly();
            else
                instance.Not.ReadOnly();
        }
    }
}

namespace T4FluentNH.Attributes
{
    //nhiberante will create a many to one relation but in code the .tt template will generate a one to one relation (in nhibernate one to one on same type will throw an stackoverflow exception!)
    //this attribute is only relevant to .tt template
    public class AsOneToOneAttribute : Attribute
    {
    }
}


namespace FluentNHibernate.Automapping
{
    internal static class EntityExtensions
    {
        private static Task<bool> ContainsAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if (persistentCol == null)
            {
                return Task.FromResult(collection.Contains(item));
            }
            return persistentCol.ContainsAsync(item);
        }

        private static Task AddAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if (persistentCol == null)
            {
                collection.Add(item);
                return TaskHelper.CompletedTask;
            }
            return persistentCol.AddAsync(item);
        }

        private static Task RemoveAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if (persistentCol == null)
            {
                collection.Remove(item);
                return TaskHelper.CompletedTask;
            }
            return persistentCol.RemoveAsync(item);
        }

        private static async Task AddIfNotExistAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if (persistentCol == null)
            {
                AddIfNotExist(collection, item);
                return;
            }
            if (await persistentCol.ContainsAsync(item).ConfigureAwait(false))
            {
                await persistentCol.AddAsync(item).ConfigureAwait(false);
                return;
            }
        }

        private static async Task RemoveIfExistAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if(persistentCol == null)
            {
                RemoveIfExist(collection, item);
                return;
            }
            if(await persistentCol.ContainsAsync(item).ConfigureAwait(false))
            {
                await persistentCol.RemoveAsync(item).ConfigureAwait(false);
                return;
            }
        }

        public static async Task AddOneToManyAsync<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, Func<TMany, Task>>> removeManyExpr)
            where TOne : T4FluentNH.Domain.IEntity
            where TMany : T4FluentNH.Domain.IEntity
        {
            if (many == null) return;
            if (!NHibernateUtil.IsInitialized(many))
                await NHibernateUtil.InitializeAsync(many).ConfigureAwait(false);
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var entityOwnerPropInfo = GetPropertyInfo(many, oneExpr);
            var itemOwner = oneExpr.Compile()(many);
            if (itemOwner != null && !NHibernateUtil.IsInitialized(one))
                await NHibernateUtil.InitializeAsync(itemOwner).ConfigureAwait(false);
            if (await ContainsAsync(collection, many).ConfigureAwait(false)) return;
            if (itemOwner != null)
                await removeManyExpr.Compile()(itemOwner)(many).ConfigureAwait(false);
            entityOwnerPropInfo.SetValue(many, one);
            await AddAsync(collection, many).ConfigureAwait(false);
        }

        public static async Task RemoveOneToManyAsync<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> entityExpr
            )
            where TOne : T4FluentNH.Domain.IEntity
            where TMany : T4FluentNH.Domain.IEntity
        {
            if (many == null) return;
            if (!NHibernateUtil.IsInitialized(many))
                await NHibernateUtil.InitializeAsync(many).ConfigureAwait(false);
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var entityOwnerPropInfo = GetPropertyInfo(many, entityExpr);

            if (!await ContainsAsync(collection, many).ConfigureAwait(false)) return;
            await RemoveAsync(collection, many).ConfigureAwait(false);
            entityOwnerPropInfo.SetValue(many, null);
        }

        public static async Task SetManyToOneAsync<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr, TOne newOne,
            Expression<Func<TOne, Func<TMany, Task>>> removeManyExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyExp)
            where TOne : T4FluentNH.Domain.IEntity
            where TMany : T4FluentNH.Domain.IEntity
        {
            if (newOne == null)
            {
                await many.UnsetManyToOneAsync(oneExpr, manyExp).ConfigureAwait(false);
                return;
            }
            if (!NHibernateUtil.IsInitialized(newOne))
                await NHibernateUtil.InitializeAsync(newOne).ConfigureAwait(false);
            var one = oneExpr.Compile()(many);
            if(one != null && !NHibernateUtil.IsInitialized(one))
                await NHibernateUtil.InitializeAsync(one).ConfigureAwait(false);
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyExp.Compile()(newOne);
            if (Equals(one, newOne)) return;
            if (one != null)
                await removeManyExpr.Compile()(one)(many).ConfigureAwait(false);
            onePropInfo.SetValue(many, newOne);
            await AddIfNotExistAsync(manyList, many).ConfigureAwait(false);
        }

        public static async Task UnsetManyToOneAsync<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr)
            where TOne : T4FluentNH.Domain.IEntity
            where TMany : T4FluentNH.Domain.IEntity
        {
            var one = oneExpr.Compile()(many);
            if (one == null) return;
            if (!NHibernateUtil.IsInitialized(one))
                await NHibernateUtil.InitializeAsync(one).ConfigureAwait(false);
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(one);
            await RemoveIfExistAsync(manyList, many).ConfigureAwait(false);
            onePropInfo.SetValue(many, null);
        }

        public static async Task AddManyToManyAsync<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : T4FluentNH.Domain.IEntity
            where TMany2 : T4FluentNH.Domain.IEntity
        {
            if (many2 == null) return;
            if (!NHibernateUtil.IsInitialized(many2))
                await NHibernateUtil.InitializeAsync(many2).ConfigureAwait(false);
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);
            await AddIfNotExistAsync(manyList, many).ConfigureAwait(false);
            await AddIfNotExistAsync(many2List, many2).ConfigureAwait(false);
        }

        public static async Task RemoveManyToManyAsync<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : T4FluentNH.Domain.IEntity
            where TMany2 : T4FluentNH.Domain.IEntity
        {
            if (many2 == null) return;
            if (!NHibernateUtil.IsInitialized(many2))
                await NHibernateUtil.InitializeAsync(many2).ConfigureAwait(false);
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);
            await RemoveIfExistAsync(manyList, many).ConfigureAwait(false);
            await RemoveIfExistAsync(many2List, many2).ConfigureAwait(false);
        }

        public static async Task SetOneToOneAsync<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr, TOne2 one2,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : T4FluentNH.Domain.IEntity
            where TOne2 : T4FluentNH.Domain.IEntity
        {
            if (one2 == null)
            {
                one.UnsetOneToOne(one2Expr, oneExpr);
                return;
            }
            if (!NHibernateUtil.IsInitialized(one2))
                await NHibernateUtil.InitializeAsync(one2).ConfigureAwait(false);

            var oneInOne2 = oneExpr.Compile()(one2);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);
            var currentOne2 = one2Expr.Compile()(one);
            var currentOne2PropInfo = GetPropertyInfo(one, one2Expr);

            if (oneInOne2 != null)
            {
                if (!NHibernateUtil.IsInitialized(oneInOne2))
                    await NHibernateUtil.InitializeAsync(oneInOne2).ConfigureAwait(false);
                await oneInOne2.UnsetOneToOneAsync(one2Expr, oneExpr).ConfigureAwait(false);
            }
            oneInOne2PropInfo.SetValue(one2, one);
            if (currentOne2 != null)
            {
                if (!NHibernateUtil.IsInitialized(currentOne2))
                    await NHibernateUtil.InitializeAsync(currentOne2).ConfigureAwait(false);
                await currentOne2.UnsetOneToOneAsync(oneExpr, one2Expr).ConfigureAwait(false);
            }
            currentOne2PropInfo.SetValue(one, one2);
        }

        public static async Task UnsetOneToOneAsync<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : T4FluentNH.Domain.IEntity
            where TOne2 : T4FluentNH.Domain.IEntity
        {
            var one2 = one2Expr.Compile()(one);
            if (one2 == null) return;
            if (!NHibernateUtil.IsInitialized(one2))
                await NHibernateUtil.InitializeAsync(one2).ConfigureAwait(false);
            var one2PropInfo = GetPropertyInfo(one, one2Expr);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);

            oneInOne2PropInfo.SetValue(one2, null);
            one2PropInfo.SetValue(one, null);
        }

        private static void RemoveIfExist<T>(ICollection<T> collection, T item)
        {
            if (collection.Contains(item))
                collection.Remove(item);
        }

        private static void AddIfNotExist<T>(ICollection<T> collection, T item)
        {
            if (!collection.Contains(item))
                collection.Add(item);
        }

        public static PropertyInfo GetPropertyInfo<TSource, TProperty>(TSource source, Expression<Func<TSource, TProperty>> propertyLambda)
        {
            var type = typeof(TSource);

            var member = propertyLambda.Body as MemberExpression;
            if (member == null)
                throw new ArgumentException(string.Format(
                    "Expression '{0}' refers to a method, not a property.",
                    propertyLambda));

            var propInfo = member.Member as PropertyInfo;
            if (propInfo == null)
                throw new ArgumentException(string.Format(
                    "Expression '{0}' refers to a field, not a property.",
                    propertyLambda.ToString()));

            if (type != propInfo.ReflectedType &&
                !type.IsSubclassOf(propInfo.ReflectedType))
                throw new ArgumentException(string.Format(
                    "Expresion '{0}' refers to a property that is not from type {1}.",
                    propertyLambda.ToString(),
                    type));

            return propInfo;
        }

        public static void AddOneToMany<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, Action<TMany>>> removeManyExpr)
            where TOne : T4FluentNH.Domain.IEntity
            where TMany : T4FluentNH.Domain.IEntity
        {
            if (many == null) return;
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var itemOwner = oneExpr.Compile()(many);
            var entityOwnerPropInfo = GetPropertyInfo(many, oneExpr);

            if (collection.Contains(many)) return;
            if (itemOwner != null)
                removeManyExpr.Compile()(itemOwner)(many);
            entityOwnerPropInfo.SetValue(many, one);
            collection.Add(many);

            /*
            if (location == null || Locations.Contains(location)) return;
            if (location.User != null)
                location.User.RemoveLocation(location);
            location.User = this;
            Locations.Add(location);
            */
        }

        public static void RemoveOneToMany<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> entityExpr
            )
            where TOne : T4FluentNH.Domain.IEntity
            where TMany : T4FluentNH.Domain.IEntity
        {
            if (many == null) return;
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var entityOwnerPropInfo = GetPropertyInfo(many, entityExpr);

            if (!collection.Contains(many)) return;
            collection.Remove(many);
            entityOwnerPropInfo.SetValue(many, null);

            /*
            if (location == null || !Locations.Contains(location)) return;
            Locations.Remove(location);
            location.User = null;
            */
        }

        public static void SetManyToOne<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr, TOne newOne,
            Expression<Func<TOne, Action<TMany>>> removeManyExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyExp)
            where TOne : T4FluentNH.Domain.IEntity
            where TMany : T4FluentNH.Domain.IEntity
        {
            if(newOne == null)
            {
                many.UnsetManyToOne(oneExpr, manyExp);
                return;
            }
            var one = oneExpr.Compile()(many);
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyExp.Compile()(newOne);

            if (Equals(one, newOne)) return;
            if (one != null)
                removeManyExpr.Compile()(one)(many);
            onePropInfo.SetValue(many, newOne);
            AddIfNotExist(manyList, many);

            /*
            if (user == null)
            {
                UnsetUser();
            }
            if (User == user) return;
            if(User != null)
                User.RemoveLocation(this);
            User = user;
            AddIfNotExist(user.Locations, this);
            */
        }

        public static void UnsetManyToOne<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr)
            where TOne : T4FluentNH.Domain.IEntity
            where TMany : T4FluentNH.Domain.IEntity
        {
            var one = oneExpr.Compile()(many);
            if (one == null) return;
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(one);

            RemoveIfExist(manyList, many);
            onePropInfo.SetValue(many, null);
            /*
            if(User == null) return;
            RemoveIfExist(User.Locations, this);
            User = null;*/
        }

        public static void AddManyToMany<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : T4FluentNH.Domain.IEntity
            where TMany2 : T4FluentNH.Domain.IEntity
        {
            if (many2 == null) return;
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);

            AddIfNotExist(manyList, many);
            AddIfNotExist(many2List, many2);
            /*
            camera.Locations.AddIfNotExist(this);
            Cameras.AddIfNotExist(camera);*/
        }

        public static void RemoveManyToMany<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : T4FluentNH.Domain.IEntity
            where TMany2 : T4FluentNH.Domain.IEntity
        {
            if (many2 == null) return;
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);

            RemoveIfExist(manyList, many);
            RemoveIfExist(many2List, many2);
            /*
            RemoveIfExist(camera.Locations, this);
            RemoveIfExist(Cameras, camera);*/
        }

        public static void SetOneToOne<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr, TOne2 one2,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : T4FluentNH.Domain.IEntity
            where TOne2 : T4FluentNH.Domain.IEntity
        {
            if(one2 == null)
            {
                one.UnsetOneToOne(one2Expr, oneExpr);
                return;
            }
            var oneInOne2 = oneExpr.Compile()(one2);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);
            var currentOne2 = one2Expr.Compile()(one);
            var currentOne2PropInfo = GetPropertyInfo(one, one2Expr);

            if (oneInOne2 != null)
                oneInOne2.UnsetOneToOne(one2Expr, oneExpr);
            oneInOne2PropInfo.SetValue(one2, one);
            if (currentOne2 != null)
                currentOne2.UnsetOneToOne(oneExpr, one2Expr);
            currentOne2PropInfo.SetValue(one, one2);
            /*
            if(value == null)
            {
                MerryWith.UnSetMerryWith();
            }
             if(MerryWith.MerriedWith != null)
               MerryWith.UnSet
             MerryWith.MerriedWith = this;
             if(MerryWith != null)
               UnSetMerryWith
             MerriedWith = value;
             */
        }

        public static void UnsetOneToOne<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : T4FluentNH.Domain.IEntity
            where TOne2 : T4FluentNH.Domain.IEntity
        {
            var one2 = one2Expr.Compile()(one);
            if (one2 == null) return;
            var one2PropInfo = GetPropertyInfo(one, one2Expr);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);

            oneInOne2PropInfo.SetValue(one2, null);
            one2PropInfo.SetValue(one, null);

            /*
            if (MerriedWith == null) return;
            MerriedWith.MerriedWith = null;  
            MerriedWith = null;
             */
        }

        private static object GetDefault(Type type)
        {
            if (type.IsValueType)
            {
                return Activator.CreateInstance(type);
            }
            return null;
        }
    }


    internal static class ExpressionExtensions
    {
        internal static string GetFullPropertyName<T, TProperty>(this Expression<Func<T, TProperty>> exp)
        {
            MemberExpression memberExp;
            if (!TryFindMemberExpression(exp.Body, out memberExp))
                return string.Empty;

            var memberNames = new Stack<string>();
            do
            {
                memberNames.Push(memberExp.Member.Name);
            }
            while (TryFindMemberExpression(memberExp.Expression, out memberExp));

            return string.Join(".", memberNames.ToArray());
        }

        private static bool TryFindMemberExpression(Expression exp, out MemberExpression memberExp)
        {
            memberExp = exp as MemberExpression;
            if (memberExp != null)
            {
                // heyo! that was easy enough
                return true;
            }

            // if the compiler created an automatic conversion,
            // it'll look something like...
            // obj => Convert(obj.Property) [e.g., int -> object]
            // OR:
            // obj => ConvertChecked(obj.Property) [e.g., int -> long]
            // ...which are the cases checked in IsConversion
            if (IsConversion(exp) && exp is UnaryExpression)
            {
                memberExp = ((UnaryExpression)exp).Operand as MemberExpression;
                if (memberExp != null)
                {
                    return true;
                }
            }

            return false;
        }

        private static bool IsConversion(Expression exp)
        {
            return (
                exp.NodeType == ExpressionType.Convert ||
                exp.NodeType == ExpressionType.ConvertChecked
            );
        }
    }


    public class Magic<TBase, TInherited> where TInherited : TBase
    {
        private Magic()
        {
        }
    }

    public static class T4FluentExtensions
    {
        /// <summary>
        /// Specify the key column name using the given expression with additional "Id" postfix
        /// </summary>
        /// <typeparam name="TChild"></typeparam>
        /// <param name="oneToMany"></param>
        /// <param name="columnExp"></param>
        /// <returns></returns>
        public static OneToManyPart<TChild> KeyColumn<TChild>(this OneToManyPart<TChild> oneToMany, Expression<Func<TChild, object>> columnExp, Magic<T4FluentNH.Tests.CodeList, TChild> x = null)
            where TChild : T4FluentNH.Tests.CodeList
        {
            return oneToMany.KeyColumn("" + columnExp.GetFullPropertyName() + "Code");
        }
        /// <summary>
        /// Specify the key column name using the given expression with additional "Id" postfix
        /// </summary>
        /// <typeparam name="TChild"></typeparam>
        /// <param name="oneToMany"></param>
        /// <param name="columnExp"></param>
        /// <returns></returns>
        public static OneToManyPart<TChild> KeyColumn<TChild>(this OneToManyPart<TChild> oneToMany, Expression<Func<TChild, object>> columnExp, Magic<T4FluentNH.Domain.Entity, TChild> x = null)
            where TChild : T4FluentNH.Domain.Entity
        {
            return oneToMany.KeyColumn("" + columnExp.GetFullPropertyName() + "Id");
        }
        /// <summary>
        /// Specify the key column name using the given expression with additional "Id" postfix
        /// </summary>
        /// <typeparam name="TChild"></typeparam>
        /// <param name="oneToMany"></param>
        /// <param name="columnExp"></param>
        /// <returns></returns>
        public static OneToManyPart<TChild> KeyColumn<TChild>(this OneToManyPart<TChild> oneToMany, Expression<Func<TChild, object>> columnExp, Magic<T4FluentNH.Domain.IUser, TChild> x = null)
            where TChild : T4FluentNH.Domain.IUser
        {
            return oneToMany.KeyColumn("" + columnExp.GetFullPropertyName() + "Id");
        }
    }

}

